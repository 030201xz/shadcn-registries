{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-asset",
  "dependencies": [
    "shaka-player",
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/use-player.json",
    "https://limeplay.winoffrg.dev/r/use-playlist.json",
    "https://limeplay.winoffrg.dev/r/use-playback.json",
    "https://limeplay.winoffrg.dev/r/media-provider.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-asset.ts",
      "content": "\"use client\"\n\nimport type shaka from \"shaka-player\"\n\nimport { useEffect } from \"react\"\n\nimport type {\n  PlaylistItem,\n  PlaylistItemInput,\n} from \"@/registry/default/hooks/use-playlist\"\n\nimport { usePlayback } from \"@/registry/default/hooks/use-playback\"\nimport { usePlayer } from \"@/registry/default/hooks/use-player\"\nimport { usePlaylist } from \"@/registry/default/hooks/use-playlist\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport interface Asset {\n  config?: shaka.extern.PlayerConfiguration\n  description?: string\n  id: string\n  poster?: string\n  src: string\n  title?: string\n}\n\nexport interface UseAssetReturn {\n  append: (items: PlaylistItemInput<Asset>[]) => void\n  appendAssets: (assets: Asset[]) => void\n  cancelPreload: (assetId: string) => void\n  clear: () => void\n  cycleRepeatMode: () => void\n  getCurrentItem: () => null | PlaylistItem<Asset>\n  getItem: (id: string) => null | PlaylistItem<Asset>\n  getNextItem: () => null | PlaylistItem<Asset>\n  getPrevItem: () => null | PlaylistItem<Asset>\n  hasNext: () => boolean\n  insert: (items: PlaylistItemInput<Asset>[], atIndex: number) => void\n  isPreloaded: (assetId: string) => boolean\n  load: (items: PlaylistItemInput<Asset>[], startIndex?: number) => void\n  loadAsset: (asset: Asset) => Promise<boolean>\n  loadPlaylist: (assets: Asset[], startIndex?: number) => void\n  newSession: () => string\n  next: () => Promise<boolean>\n  playNext: (items: PlaylistItemInput<Asset>[]) => void\n  preloadAsset: (asset: Asset) => Promise<void>\n  preloadNext: () => Promise<void>\n  prepend: (items: PlaylistItemInput<Asset>[]) => void\n  previous: () => Promise<boolean>\n  remove: (id: string) => void\n  removeAt: (index: number) => void\n  reorder: (fromIndex: number, toIndex: number) => void\n  setRepeatMode: (mode: \"all\" | \"off\" | \"one\") => void\n  setShuffle: (enabled: boolean) => void\n  skipTo: (index: number) => Promise<void>\n  skipToId: (id: string) => Promise<void>\n  toggleShuffle: () => void\n}\n\nexport function useAsset(): UseAssetReturn {\n  const player = useMediaStore((state) => state.player)\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n  const store = useGetStore()\n\n  const { play } = usePlayback()\n\n  const playback = usePlayer<Asset>({\n    onError: (error: Error, asset?: Asset) => {\n      console.error(\"[useAsset] Playback error:\", error, asset?.id)\n      throw error\n    },\n    onLoad: async (\n      asset: Asset,\n      shakaPlayer: shaka.Player,\n      _media: HTMLMediaElement,\n      preloadManager?: shaka.media.PreloadManager\n    ) => {\n      if (asset.config) {\n        shakaPlayer.resetConfiguration()\n        shakaPlayer.configure(asset.config)\n      }\n\n      if (preloadManager) {\n        await shakaPlayer.load(preloadManager)\n      } else {\n        await shakaPlayer.load(asset.src)\n      }\n\n      if (player && mediaRef.current && mediaRef.current.autoplay) {\n        await play()\n      }\n    },\n    onPreload: async (\n      asset: Asset,\n      shakaPlayer: shaka.Player\n    ): Promise<null | shaka.media.PreloadManager> => {\n      return shakaPlayer.preload(asset.src, undefined, undefined, asset.config)\n    },\n  })\n\n  const playlist = usePlaylist<Asset>({\n    onError: (item: PlaylistItem<Asset>, error: Error) => {\n      console.error(\"[useAsset] Playlist error:\", item.id, error)\n\n      playlist.next()\n    },\n    onLoadItem: async (item: PlaylistItem<Asset>) => {\n      const asset = item.properties\n\n      await playback.load(asset)\n    },\n  })\n\n  const onItemEnded = () => {\n    if (playlist.hasNext()) {\n      playlist.next()\n    }\n  }\n\n  useEffect(() => {\n    store.setState({\n      onEnded: onItemEnded,\n    })\n  }, [onItemEnded])\n\n  /**\n   * Load a playlist of assets\n   */\n  const loadPlaylist = (assets: Asset[], startIndex = 0) => {\n    const items = assets.map((asset) => ({\n      id: asset.id,\n      properties: asset,\n    }))\n\n    playlist.load(items, startIndex)\n  }\n\n  /**\n   * Append assets to the queue\n   */\n  const appendAssets = (assets: Asset[]) => {\n    const items = assets.map((asset) => ({\n      id: asset.id,\n      properties: asset,\n    }))\n    playlist.append(items)\n  }\n\n  /**\n   * Load a single asset directly (bypasses playlist)\n   */\n  const loadAsset = async (asset: Asset) => {\n    return playback.load(asset)\n  }\n\n  /**\n   * Preload the next asset in the queue\n   */\n  const preloadNext = async () => {\n    const nextItem = playlist.getNextItem()\n    if (nextItem) {\n      await playback.preload(nextItem.properties)\n    }\n  }\n\n  const preloadAsset = async (asset: Asset) => {\n    return playback.preload(asset)\n  }\n\n  return {\n    ...playlist,\n    appendAssets,\n    cancelPreload: playback.cancelPreload,\n    isPreloaded: playback.isPreloaded,\n    loadAsset,\n    loadPlaylist,\n    preloadAsset,\n    preloadNext,\n  }\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-asset.ts"
    }
  ],
  "type": "registry:hook"
}