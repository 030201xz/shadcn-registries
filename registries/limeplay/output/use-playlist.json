{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-playlist",
  "dependencies": [
    "lodash",
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/utils.json",
    "https://limeplay.winoffrg.dev/r/media-provider.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-playlist.ts",
      "content": "\"use client\"\n\nimport type { StateCreator } from \"zustand\"\n\nimport clamp from \"lodash/clamp\"\nimport pull from \"lodash/pull\"\nimport reject from \"lodash/reject\"\nimport shuffle from \"lodash/shuffle\"\nimport React from \"react\"\n\nimport { noop, off, on } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport interface PlaylistItem<T = Record<string, unknown>> {\n  error?: Error | null\n  id: string\n  properties: T\n  status: PlaylistItemStatus\n}\n\nexport interface PlaylistItemInput<T = Record<string, unknown>> {\n  id: string\n  properties?: T\n}\n\nexport type PlaylistItemStatus =\n  | \"error\"\n  | \"idle\"\n  | \"loading\"\n  | \"played\"\n  | \"playing\"\n  | \"ready\"\n  | \"skipped\"\n\nexport interface PlaylistStore {\n  currentIndex: number\n  currentItem: null | PlaylistItem\n  history: PlaylistItem[]\n  onItemError?: (payload: { error: Error; item: PlaylistItem }) => void\n  onItemLoad?: (payload: { index: number; item: PlaylistItem }) => void\n  onPlaylistChange?: (payload: {\n    currentIndex: number\n    currentItem: null | PlaylistItem\n  }) => void\n  queue: PlaylistItem[]\n  repeatMode: RepeatMode\n\n  sessionId: string\n  shuffle: boolean\n  shuffleOrder: number[]\n}\n\nexport type RepeatMode = \"all\" | \"off\" | \"one\"\n\nfunction createShuffleOrder(length: number, excludeIndex?: number): number[] {\n  const indices = Array.from({ length }, (_, i) => i)\n\n  if (\n    excludeIndex !== undefined &&\n    excludeIndex >= 0 &&\n    excludeIndex < length\n  ) {\n    const shuffledIndices = shuffle(pull([...indices], excludeIndex))\n    return [excludeIndex, ...shuffledIndices]\n  }\n\n  return shuffle(indices)\n}\n\nfunction generateSessionId(): string {\n  return `lp_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`\n}\n\nfunction normalizeItems<T>(inputs: PlaylistItemInput<T>[]): PlaylistItem<T>[] {\n  return inputs.map((input) => ({\n    error: null,\n    id: input.id,\n    properties: input.properties ?? ({} as T),\n    status: \"idle\" as const,\n  }))\n}\n\nexport const createPlaylistStore: StateCreator<\n  PlaylistStore,\n  [],\n  [],\n  PlaylistStore\n> = () => ({\n  currentIndex: -1,\n  currentItem: null,\n  history: [],\n  onItemError: undefined,\n  onItemLoad: undefined,\n  onPlaylistChange: undefined,\n  queue: [],\n  repeatMode: \"off\",\n\n  sessionId: generateSessionId(),\n  shuffle: false,\n  shuffleOrder: [],\n})\n\n/**\n * Options for usePlaylist hook\n */\nexport interface UsePlaylistOptions<T> {\n  onError?: (item: PlaylistItem<T>, error: Error) => void\n  onLoadItem: (item: PlaylistItem<T>) => Promise<void>\n}\n\nexport interface UsePlaylistReturn<T> {\n  append: (items: PlaylistItemInput<T>[]) => void\n  clear: () => void\n  cycleRepeatMode: () => void\n  getCurrentItem: () => null | PlaylistItem<T>\n  getItem: (id: string) => null | PlaylistItem<T>\n  getNextItem: () => null | PlaylistItem<T>\n  getPrevItem: () => null | PlaylistItem<T>\n  hasNext: () => boolean\n  insert: (items: PlaylistItemInput<T>[], atIndex: number) => void\n  load: (items: PlaylistItemInput<T>[], startIndex?: number) => void\n  newSession: () => string\n  next: () => Promise<boolean>\n  playNext: (items: PlaylistItemInput<T>[]) => void\n  prepend: (items: PlaylistItemInput<T>[]) => void\n  previous: () => Promise<boolean>\n  remove: (id: string) => void\n  removeAt: (index: number) => void\n  reorder: (fromIndex: number, toIndex: number) => void\n  setRepeatMode: (mode: RepeatMode) => void\n  setShuffle: (enabled: boolean) => void\n  skipTo: (index: number) => Promise<void>\n  skipToId: (id: string) => Promise<void>\n  toggleShuffle: () => void\n}\n\n/**\n * usePlaylist - Queue management with user-provided load callbacks\n */\nexport function usePlaylist<T>(\n  options: UsePlaylistOptions<T>\n): UsePlaylistReturn<T> {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((s) => s.mediaRef)\n  const { onError, onLoadItem } = options\n\n  const updateItemStatus = React.useCallback(\n    (itemId: string, status: PlaylistItemStatus, error?: Error) => {\n      const { queue } = store.getState()\n      const idx = queue.findIndex((q: PlaylistItem) => q.id === itemId)\n      if (idx !== -1) {\n        const updated = [...queue]\n        updated[idx] = { ...updated[idx], error: error ?? null, status }\n        store.setState({ queue: updated })\n      }\n    },\n    [store]\n  )\n\n  const loadItem = React.useCallback(\n    async (item: PlaylistItem<T>): Promise<boolean> => {\n      updateItemStatus(item.id, \"loading\")\n\n      try {\n        await onLoadItem(item)\n        updateItemStatus(item.id, \"playing\")\n\n        const currentIndex = store\n          .getState()\n          .queue.findIndex((q) => q.id === item.id)\n        store\n          .getState()\n          .onItemLoad?.({ index: currentIndex, item: item as PlaylistItem })\n\n        return true\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error))\n        updateItemStatus(item.id, \"error\", err)\n\n        store\n          .getState()\n          .onItemError?.({ error: err, item: item as PlaylistItem })\n\n        onError?.(item, err)\n        return false\n      }\n    },\n    [onLoadItem, onError, updateItemStatus, store]\n  )\n\n  const getNextIndex = React.useCallback((): number => {\n    const {\n      currentIndex,\n      queue,\n      repeatMode,\n      shuffle: isShuffleEnabled,\n      shuffleOrder,\n    } = store.getState()\n    if (queue.length === 0) return -1\n    if (repeatMode === \"one\") return currentIndex\n\n    if (isShuffleEnabled && shuffleOrder.length > 0) {\n      const currentPos = shuffleOrder.indexOf(currentIndex)\n      const nextPos = currentPos + 1\n      if (nextPos < shuffleOrder.length) return shuffleOrder[nextPos]\n      if (repeatMode === \"all\") {\n        const newOrder = createShuffleOrder(queue.length)\n        store.setState({ shuffleOrder: newOrder })\n        return newOrder[0]\n      }\n      return -1\n    }\n\n    const nextIndex = currentIndex + 1\n    if (nextIndex < queue.length) return nextIndex\n    if (repeatMode === \"all\") return 0\n    return -1\n  }, [store])\n\n  const getPreviousIndex = React.useCallback((): number => {\n    const {\n      currentIndex,\n      history,\n      queue,\n      shuffle: isShuffleEnabled,\n      shuffleOrder,\n    } = store.getState()\n    if (queue.length === 0) return -1\n\n    if (mediaRef.current && mediaRef.current.currentTime > 3) {\n      return currentIndex\n    }\n\n    if (history.length > 0) {\n      const lastItem = history[history.length - 1]\n      const idx = queue.findIndex((q: PlaylistItem) => q.id === lastItem.id)\n      if (idx !== -1) return idx\n    }\n\n    if (isShuffleEnabled && shuffleOrder.length > 0) {\n      const currentPos = shuffleOrder.indexOf(currentIndex)\n      if (currentPos > 0) return shuffleOrder[currentPos - 1]\n      return currentIndex\n    }\n\n    return currentIndex > 0 ? currentIndex - 1 : currentIndex\n  }, [store, mediaRef])\n\n  const next = React.useCallback(async (): Promise<boolean> => {\n    const { currentItem, history, queue } = store.getState()\n    const nextIndex = getNextIndex()\n    if (nextIndex === -1 || nextIndex >= queue.length) return false\n\n    if (currentItem) {\n      store.setState({ history: [...history, currentItem] })\n    }\n\n    const nextItem = queue[nextIndex] as PlaylistItem<T>\n    store.setState({\n      currentIndex: nextIndex,\n      currentItem: nextItem as PlaylistItem,\n    })\n\n    store.getState().onPlaylistChange?.({\n      currentIndex: nextIndex,\n      currentItem: nextItem as PlaylistItem,\n    })\n\n    return loadItem(nextItem)\n  }, [store, getNextIndex, loadItem])\n\n  const previous = React.useCallback(async (): Promise<boolean> => {\n    const { currentIndex, history, queue } = store.getState()\n    const prevIndex = getPreviousIndex()\n    if (prevIndex === -1 || prevIndex >= queue.length) return false\n\n    const prevItem = queue[prevIndex] as PlaylistItem<T>\n\n    if (prevIndex === currentIndex && mediaRef.current) {\n      mediaRef.current.currentTime = 0\n      return true\n    }\n\n    if (history.length > 0) {\n      store.setState({ history: history.slice(0, -1) })\n    }\n\n    store.setState({\n      currentIndex: prevIndex,\n      currentItem: prevItem as PlaylistItem,\n    })\n    return loadItem(prevItem)\n  }, [store, getPreviousIndex, loadItem, mediaRef])\n\n  const skipTo = React.useCallback(\n    async (index: number): Promise<void> => {\n      const { currentItem, history, queue } = store.getState()\n      if (index < 0 || index >= queue.length) return\n\n      if (currentItem) {\n        updateItemStatus(currentItem.id, \"skipped\")\n        store.setState({ history: [...history, currentItem] })\n      }\n\n      const item = queue[index] as PlaylistItem<T>\n      store.setState({ currentIndex: index, currentItem: item as PlaylistItem })\n      await loadItem(item)\n    },\n    [store, loadItem, updateItemStatus]\n  )\n\n  const skipToId = React.useCallback(\n    async (id: string): Promise<void> => {\n      const { queue } = store.getState()\n      const index = queue.findIndex((item: PlaylistItem) => item.id === id)\n      if (index !== -1) await skipTo(index)\n    },\n    [store, skipTo]\n  )\n\n  const load = React.useCallback(\n    (items: PlaylistItemInput<T>[], startIndex = 0): void => {\n      const normalized = normalizeItems(items)\n      const { shuffle: isShuffleEnabled } = store.getState()\n      const shuffleOrder = isShuffleEnabled\n        ? createShuffleOrder(normalized.length, startIndex)\n        : []\n\n      store.setState({\n        currentIndex: -1,\n        currentItem: null,\n        history: [],\n        queue: normalized as PlaylistItem[],\n        sessionId: generateSessionId(),\n        shuffleOrder,\n      })\n\n      if (normalized.length > 0 && startIndex < normalized.length) {\n        const startItem = normalized[startIndex] as PlaylistItem<T>\n        store.setState({\n          currentIndex: startIndex,\n          currentItem: startItem as PlaylistItem,\n        })\n        void loadItem(startItem)\n      }\n    },\n    [store, loadItem]\n  )\n\n  const append = React.useCallback(\n    (items: PlaylistItemInput<T>[]): void => {\n      const {\n        queue,\n        shuffle: isShuffleEnabled,\n        shuffleOrder,\n      } = store.getState()\n      const normalized = normalizeItems(items)\n      const newQueue = [...queue, ...normalized]\n\n      let newShuffleOrder = shuffleOrder\n      if (isShuffleEnabled) {\n        const newIndices = Array.from(\n          { length: normalized.length },\n          (_, i) => queue.length + i\n        )\n        newShuffleOrder = [...shuffleOrder, ...shuffle(newIndices)]\n      }\n\n      store.setState({\n        queue: newQueue as PlaylistItem[],\n        shuffleOrder: newShuffleOrder,\n      })\n    },\n    [store]\n  )\n\n  const prepend = React.useCallback(\n    (items: PlaylistItemInput<T>[]): void => {\n      const {\n        currentIndex,\n        queue,\n        shuffle: isShuffleEnabled,\n        shuffleOrder,\n      } = store.getState()\n      const normalized = normalizeItems(items)\n      const newQueue = [...normalized, ...queue]\n      const newCurrentIndex =\n        currentIndex >= 0 ? currentIndex + normalized.length : currentIndex\n\n      let newShuffleOrder = shuffleOrder.map(\n        (idx: number) => idx + normalized.length\n      )\n\n      if (isShuffleEnabled) {\n        const newIndices = Array.from(\n          { length: normalized.length },\n          (_, i) => i\n        )\n        const pos = shuffleOrder.indexOf(currentIndex)\n        newShuffleOrder = [\n          ...newShuffleOrder.slice(0, pos + 1),\n          ...shuffle(newIndices),\n          ...newShuffleOrder.slice(pos + 1),\n        ]\n      }\n\n      store.setState({\n        currentIndex: newCurrentIndex,\n        queue: newQueue as PlaylistItem[],\n        shuffleOrder: newShuffleOrder,\n      })\n    },\n    [store]\n  )\n\n  const insert = React.useCallback(\n    (items: PlaylistItemInput<T>[], atIndex: number): void => {\n      const { currentIndex, queue } = store.getState()\n      const normalized = normalizeItems(items)\n      const idx = clamp(atIndex, 0, queue.length)\n      const newQueue = [\n        ...queue.slice(0, idx),\n        ...normalized,\n        ...queue.slice(idx),\n      ]\n      const newCurrentIndex =\n        currentIndex >= idx ? currentIndex + normalized.length : currentIndex\n\n      store.setState({\n        currentIndex: newCurrentIndex,\n        queue: newQueue as PlaylistItem[],\n      })\n    },\n    [store]\n  )\n\n  const playNext = React.useCallback(\n    (items: PlaylistItemInput<T>[]): void => {\n      const { currentIndex } = store.getState()\n      insert(items, currentIndex + 1)\n    },\n    [store, insert]\n  )\n\n  const remove = React.useCallback(\n    (id: string): void => {\n      const { currentIndex, currentItem, queue } = store.getState()\n      const removeIndex = queue.findIndex(\n        (item: PlaylistItem) => item.id === id\n      )\n      if (removeIndex === -1) return\n\n      const newQueue = reject(queue, { id }) as PlaylistItem[]\n      let newCurrentIndex = currentIndex\n      let newCurrentItem = currentItem\n\n      if (removeIndex < currentIndex) {\n        newCurrentIndex = currentIndex - 1\n      } else if (removeIndex === currentIndex) {\n        newCurrentIndex = Math.min(currentIndex, newQueue.length - 1)\n        newCurrentItem = newQueue[newCurrentIndex] ?? null\n      }\n\n      store.setState({\n        currentIndex: newCurrentIndex,\n        currentItem: newCurrentItem,\n        queue: newQueue,\n      })\n    },\n    [store]\n  )\n\n  const removeAt = React.useCallback(\n    (index: number): void => {\n      const { queue } = store.getState()\n      if (index >= 0 && index < queue.length) {\n        remove(queue[index].id)\n      }\n    },\n    [store, remove]\n  )\n\n  const reorder = React.useCallback(\n    (fromIndex: number, toIndex: number): void => {\n      const { currentIndex, queue } = store.getState()\n      if (\n        fromIndex < 0 ||\n        fromIndex >= queue.length ||\n        toIndex < 0 ||\n        toIndex >= queue.length\n      )\n        return\n\n      const newQueue = [...queue]\n      const [removed] = newQueue.splice(fromIndex, 1)\n      newQueue.splice(toIndex, 0, removed)\n\n      let newCurrentIndex = currentIndex\n      if (fromIndex === currentIndex) {\n        newCurrentIndex = toIndex\n      } else if (fromIndex < currentIndex && toIndex >= currentIndex) {\n        newCurrentIndex = currentIndex - 1\n      } else if (fromIndex > currentIndex && toIndex <= currentIndex) {\n        newCurrentIndex = currentIndex + 1\n      }\n\n      store.setState({ currentIndex: newCurrentIndex, queue: newQueue })\n    },\n    [store]\n  )\n\n  const clear = React.useCallback((): void => {\n    store.setState({\n      currentIndex: -1,\n      currentItem: null,\n      history: [],\n      queue: [],\n      shuffleOrder: [],\n    })\n  }, [store])\n\n  const toggleShuffle = React.useCallback((): void => {\n    const { currentIndex, queue, shuffle: isShuffleOn } = store.getState()\n    const newShuffle = !isShuffleOn\n    const shuffleOrder =\n      newShuffle && queue.length > 0\n        ? createShuffleOrder(queue.length, currentIndex)\n        : []\n    store.setState({ shuffle: newShuffle, shuffleOrder })\n  }, [store])\n\n  const setShuffle = React.useCallback(\n    (enabled: boolean): void => {\n      const { currentIndex, queue, shuffle: current } = store.getState()\n      if (current === enabled) return\n      const shuffleOrder =\n        enabled && queue.length > 0\n          ? createShuffleOrder(queue.length, currentIndex)\n          : []\n      store.setState({ shuffle: enabled, shuffleOrder })\n    },\n    [store]\n  )\n\n  const setRepeatMode = React.useCallback(\n    (mode: RepeatMode): void => {\n      store.setState({ repeatMode: mode })\n    },\n    [store]\n  )\n\n  const cycleRepeatMode = React.useCallback((): void => {\n    const { repeatMode } = store.getState()\n    const modes: RepeatMode[] = [\"off\", \"all\", \"one\"]\n    const nextMode = modes[(modes.indexOf(repeatMode) + 1) % modes.length]\n    store.setState({ repeatMode: nextMode })\n  }, [store])\n\n  /**\n   * Get the next item without navigating\n   */\n  const getNextItem = React.useCallback((): null | PlaylistItem<T> => {\n    const nextIndex = getNextIndex()\n    const { queue } = store.getState()\n    if (nextIndex >= 0 && nextIndex < queue.length) {\n      return queue[nextIndex] as PlaylistItem<T>\n    }\n    return null\n  }, [getNextIndex, store])\n\n  /**\n   * Get the previous item without navigating\n   */\n  const getPrevItem = React.useCallback((): null | PlaylistItem<T> => {\n    const prevIndex = getPreviousIndex()\n    const { queue } = store.getState()\n    if (prevIndex >= 0 && prevIndex < queue.length) {\n      return queue[prevIndex] as PlaylistItem<T>\n    }\n    return null\n  }, [getPreviousIndex, store])\n\n  /**\n   * Get item by id\n   */\n  const getItem = React.useCallback(\n    (id: string): null | PlaylistItem<T> => {\n      const { queue } = store.getState()\n      const item = queue.find((q: PlaylistItem) => q.id === id)\n      return item ? (item as PlaylistItem<T>) : null\n    },\n    [store]\n  )\n\n  /**\n   * Get the currently active item\n   */\n  const getCurrentItem = React.useCallback((): null | PlaylistItem<T> => {\n    const { currentItem } = store.getState()\n    return currentItem ? (currentItem as PlaylistItem<T>) : null\n  }, [store])\n\n  const newSession = React.useCallback((): string => {\n    const sessionId = generateSessionId()\n    store.setState({ sessionId })\n    return sessionId\n  }, [store])\n\n  /**\n   * Has next item in queue\n   */\n  const hasNext = React.useCallback((): boolean => {\n    const { currentIndex, queue, repeatMode } = store.getState()\n    if (repeatMode === \"all\" && queue.length > 0) {\n      return true\n    }\n    return currentIndex >= 0 && currentIndex < queue.length - 1\n  }, [store])\n\n  return {\n    append,\n    clear,\n    cycleRepeatMode,\n    getCurrentItem,\n    getItem,\n    getNextItem,\n    getPrevItem,\n    hasNext,\n    insert,\n    load,\n    newSession,\n    next,\n    playNext,\n    prepend,\n    previous,\n    remove,\n    removeAt,\n    reorder,\n    setRepeatMode,\n    setShuffle,\n    skipTo,\n    skipToId,\n    toggleShuffle,\n  }\n}\n\nexport function usePlaylistStates() {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n\n  React.useEffect(() => {\n    if (!mediaRef.current) return noop\n\n    const media = mediaRef.current\n\n    if (media.loop) {\n      console.warn(\n        \"[use-playlist] Media is in loop mode, some features may not work as expected\"\n      )\n    }\n\n    const endedHandler = () => {\n      const { currentIndex, currentItem, queue, repeatMode } = store.getState()\n\n      if (currentItem && currentIndex >= 0 && currentIndex < queue.length) {\n        const updatedQueue = [...queue]\n\n        updatedQueue[currentIndex] = {\n          ...updatedQueue[currentIndex],\n          status: \"played\",\n        }\n        store.setState({ queue: updatedQueue })\n      }\n\n      if (repeatMode === \"one\") {\n        if (!media.loop) {\n          media.loop = true\n        }\n      } else {\n        if (media.loop) {\n          media.loop = false\n        }\n      }\n    }\n\n    on(media, \"ended\", endedHandler)\n    return () => off(media, \"ended\", endedHandler)\n  }, [mediaRef, store])\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-playlist.ts"
    }
  ],
  "type": "registry:hook"
}