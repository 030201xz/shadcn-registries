{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-picture-in-picture",
  "dependencies": [
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/use-playback.json",
    "https://limeplay.winoffrg.dev/r/utils.json",
    "https://limeplay.winoffrg.dev/r/media-provider.json",
    "https://limeplay.winoffrg.dev/r/player-hooks.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-picture-in-picture.ts",
      "content": "import type { StateCreator } from \"zustand\"\n\nimport React from \"react\"\n\nimport { noop, off, on } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport interface PictureInPictureStore {\n  isPictureInPictureActive: boolean\n  isPictureInPictureSupported: boolean\n  onEnterPictureInPicture?: () => void\n  onLeavePictureInPicture?: () => void\n}\n\ninterface ExtendedHTMLVideoElement extends HTMLVideoElement {\n  webkitPresentationMode?: string\n  webkitSetPresentationMode?: (mode: string) => void\n  webkitSupportsPresentationMode?: (mode: string) => boolean\n}\n\nexport const createPictureInPictureStore: StateCreator<\n  PictureInPictureStore,\n  [],\n  [],\n  PictureInPictureStore\n> = () => ({\n  isPictureInPictureActive: false,\n  isPictureInPictureSupported: false,\n  onEnterPictureInPicture: undefined,\n  onLeavePictureInPicture: undefined,\n})\n\nexport interface UsePictureInPictureReturn {\n  enterPictureInPicture: () => Promise<void>\n  exitPictureInPicture: () => Promise<void>\n  togglePictureInPicture: () => Promise<void>\n}\n\nexport function usePictureInPicture(): UsePictureInPictureReturn {\n  const store = useGetStore()\n\n  async function enterPictureInPicture() {\n    const media = store.getState().mediaRef\n      .current as ExtendedHTMLVideoElement | null\n    if (!media || media.nodeName.toLowerCase() !== \"video\") return\n\n    try {\n      if (isWebkitPictureInPictureSupported(media)) {\n        media.webkitSetPresentationMode!(\"picture-in-picture\")\n      } else {\n        await media.requestPictureInPicture()\n      }\n    } catch (error) {\n      console.error(\"Failed to enter Picture-in-Picture mode:\", error)\n    }\n  }\n\n  async function exitPictureInPicture() {\n    const media = store.getState().mediaRef\n      .current as ExtendedHTMLVideoElement | null\n\n    if (!media) return\n\n    try {\n      if (isWebkitPictureInPictureSupported(media)) {\n        media.webkitSetPresentationMode!(\"inline\")\n      } else if (document.pictureInPictureElement) {\n        await document.exitPictureInPicture()\n      }\n    } catch (error) {\n      console.error(\"Failed to exit Picture-in-Picture mode:\", error)\n    }\n  }\n\n  async function togglePictureInPicture() {\n    const isPictureInPictureActive = store.getState().isPictureInPictureActive\n\n    if (isPictureInPictureActive) {\n      await exitPictureInPicture()\n    } else {\n      await enterPictureInPicture()\n    }\n  }\n\n  return {\n    enterPictureInPicture,\n    exitPictureInPicture,\n    togglePictureInPicture,\n  }\n}\n\nexport function usePictureInPictureStates() {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n\n  React.useEffect(() => {\n    const media = mediaRef.current as ExtendedHTMLVideoElement | null\n    if (!media || media.nodeName.toLowerCase() !== \"video\") return noop\n\n    const updatePictureInPictureSupport = () => {\n      const browserSupports =\n        document.pictureInPictureEnabled ||\n        isWebkitPictureInPictureSupported(media)\n\n      const isPictureInPictureSupported =\n        browserSupports && hasVideoTrack(media)\n\n      store.setState({\n        isPictureInPictureSupported,\n      })\n    }\n\n    updatePictureInPictureSupport()\n\n    const enterPictureInPictureHandler = () => {\n      store.setState({ isPictureInPictureActive: true })\n      store.getState().onEnterPictureInPicture?.()\n    }\n\n    const leavePictureInPictureHandler = () => {\n      store.setState({ isPictureInPictureActive: false })\n      store.getState().onLeavePictureInPicture?.()\n    }\n\n    const webkitPresentationModeHandler = () => {\n      const isActive = media.webkitPresentationMode === \"picture-in-picture\"\n      if (isActive) {\n        enterPictureInPictureHandler()\n      } else {\n        leavePictureInPictureHandler()\n      }\n    }\n\n    on(media, \"enterpictureinpicture\", enterPictureInPictureHandler)\n    on(media, \"leavepictureinpicture\", leavePictureInPictureHandler)\n    on(media, \"loadedmetadata\", updatePictureInPictureSupport)\n    on(media, \"emptied\", updatePictureInPictureSupport)\n\n    if (isWebkitPictureInPictureSupported(media)) {\n      on(media, \"webkitpresentationmodechanged\", webkitPresentationModeHandler)\n    }\n\n    return () => {\n      off(media, \"enterpictureinpicture\", enterPictureInPictureHandler)\n      off(media, \"leavepictureinpicture\", leavePictureInPictureHandler)\n      off(media, \"loadedmetadata\", updatePictureInPictureSupport)\n      off(media, \"emptied\", updatePictureInPictureSupport)\n\n      if (isWebkitPictureInPictureSupported(media)) {\n        off(\n          media,\n          \"webkitpresentationmodechanged\",\n          webkitPresentationModeHandler\n        )\n      }\n    }\n  }, [store, mediaRef])\n}\n\nfunction hasVideoTrack(media: HTMLVideoElement): boolean {\n  return media.videoWidth > 0 && media.videoHeight > 0\n}\n\nfunction isWebkitPictureInPictureSupported(\n  media: ExtendedHTMLVideoElement\n): boolean {\n  return (\n    typeof media.webkitSupportsPresentationMode === \"function\" &&\n    media.webkitSupportsPresentationMode(\"picture-in-picture\") &&\n    typeof media.webkitSetPresentationMode === \"function\"\n  )\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-picture-in-picture.ts"
    }
  ],
  "type": "registry:hook"
}