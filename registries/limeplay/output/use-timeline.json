{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-timeline",
  "dependencies": [
    "lodash.clamp",
    "zustand"
  ],
  "devDependencies": [
    "@types/lodash.clamp"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/use-player.json",
    "https://limeplay.winoffrg.dev/r/utils.json",
    "https://limeplay.winoffrg.dev/r/media-provider.json",
    "https://limeplay.winoffrg.dev/r/use-interval.json",
    "https://limeplay.winoffrg.dev/r/player-hooks.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-timeline.ts",
      "content": "\"use client\"\n\nimport type shaka from \"shaka-player\"\nimport type { StateCreator } from \"zustand\"\n\nimport clamp from \"lodash.clamp\"\nimport React, { useCallback } from \"react\"\n\nimport { useInterval } from \"@/registry/default/hooks/use-interval\"\nimport {\n  MediaReadyState,\n  type PlayerStore,\n} from \"@/registry/default/hooks/use-player\"\nimport { noop, off, on, toFixedNumber } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport interface TimelineStore {\n  buffered: shaka.extern.BufferedRange[]\n  currentTime: number\n  duration: number\n  hoveringTime: number\n  isHovering: boolean\n  isLive: boolean\n  liveLatency: null | number\n  progress: number\n}\n\nexport const createTimelineStore: StateCreator<\n  PlayerStore & TimelineStore,\n  [],\n  [],\n  TimelineStore\n> = () => ({\n  buffered: [],\n  currentTime: 0,\n  duration: 0,\n  hoveringTime: 0,\n  isHovering: false,\n  isLive: false,\n  liveLatency: null,\n  progress: 0,\n})\n\nexport interface useTimelineStatesProps {\n  /**\n   * Interval in milliseconds to update the states\n   * @default 500\n   */\n  updateDuration?: number\n}\n\nexport function useTimeline() {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n  const duration = useMediaStore((state) => state.duration)\n  const isLive = useMediaStore((state) => state.isLive)\n  const player = useMediaStore((state) => state.player)\n\n  const getTimeFromEvent = useCallback(\n    (event: React.PointerEvent) => {\n      const rect = event.currentTarget.getBoundingClientRect()\n      const percentage = (event.clientX - rect.left) / rect.width\n      const clampedPercentage = Math.max(0, Math.min(1, percentage))\n      return duration ? clampedPercentage * duration : 0\n    },\n    [duration]\n  )\n\n  const seek = useCallback(\n    (time: number) => {\n      if (!mediaRef.current || !Number.isFinite(duration)) return\n\n      const media = mediaRef.current\n\n      let actualSeekTime = time\n      let storeCurrentTime = time\n\n      if (isLive && player) {\n        const seekRange = player.seekRange()\n        actualSeekTime = clamp(time, seekRange.start, seekRange.end)\n        storeCurrentTime = actualSeekTime - seekRange.start\n      } else {\n        actualSeekTime = clamp(time, 0, duration)\n        storeCurrentTime = actualSeekTime\n      }\n\n      store.setState({\n        currentTime: storeCurrentTime,\n        progress: storeCurrentTime / duration,\n      })\n\n      media.currentTime = actualSeekTime\n    },\n    [mediaRef, duration, isLive, player, store]\n  )\n\n  const setHoveringTime = useCallback(\n    (time: number) => {\n      if (!Number.isFinite(store.getState().duration)) return\n\n      store.setState({\n        hoveringTime: time,\n      })\n    },\n    [store]\n  )\n\n  function setIsHovering(isHovering: boolean) {\n    store.setState({ isHovering })\n  }\n\n  const processBufferedRanges = useCallback(\n    (\n      bufferedRanges: shaka.extern.BufferedRange[],\n      variant: \"combined\" | \"default\" | \"from-zero\" = \"default\"\n    ): Array<{ startPercent: number; widthPercent: number }> => {\n      if (!bufferedRanges.length || !duration) {\n        return []\n      }\n\n      let normalizedBuffered: shaka.extern.BufferedRange[] = []\n\n      if (variant === \"combined\") {\n        const combinedBuffered = bufferedRanges.reduce(\n          (acc, range) => {\n            acc.start = Math.min(acc.start, range.start)\n            acc.end = Math.max(acc.end, range.end)\n            return acc\n          },\n          { end: 0, start: Infinity }\n        )\n\n        if (combinedBuffered.start !== Infinity) {\n          normalizedBuffered = [\n            {\n              end: combinedBuffered.end,\n              start: combinedBuffered.start,\n            },\n          ]\n        }\n      } else if (variant === \"from-zero\") {\n        normalizedBuffered = bufferedRanges.map((range) => ({\n          end: range.end,\n          start: 0,\n        }))\n      } else {\n        normalizedBuffered = bufferedRanges\n      }\n\n      if (!normalizedBuffered.length) {\n        return []\n      }\n\n      return normalizedBuffered.map((range) => {\n        let startPercent: number\n        let widthPercent: number\n\n        if (isLive && player) {\n          const seekRange = player.seekRange()\n          const relativeStart = Math.max(0, range.start - seekRange.start)\n          const relativeEnd = Math.max(0, range.end - seekRange.start)\n\n          startPercent = (relativeStart / duration) * 100\n          widthPercent = ((relativeEnd - relativeStart) / duration) * 100\n        } else {\n          startPercent = (range.start / duration) * 100\n          widthPercent = ((range.end - range.start) / duration) * 100\n        }\n\n        return { startPercent, widthPercent }\n      })\n    },\n    [duration, isLive, player]\n  )\n\n  return {\n    getTimeFromEvent,\n    processBufferedRanges,\n    seek,\n    setHoveringTime,\n    setIsHovering,\n  }\n}\n\nexport function useTimelineStates({\n  updateDuration = 500,\n}: useTimelineStatesProps = {}) {\n  const store = useGetStore()\n  const player = useMediaStore((s) => s.player)\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n  const canPlay = useMediaStore((state) => state.canPlay)\n  const readyState = useMediaStore((state) => state.readyState)\n\n  const isLive = player?.isLive() ?? false\n\n  const onTimeUpdate = () => {\n    if (!mediaRef.current || !player) return\n\n    if (readyState < MediaReadyState.HAVE_METADATA) return\n\n    let currentTime = mediaRef.current.currentTime\n    let liveLatency = isLive ? 0 : null\n    let progress = 0\n\n    if (isLive) {\n      const seekRange = player.seekRange()\n      liveLatency =\n        mediaRef.current.currentTime === 0\n          ? 0\n          : seekRange.end - mediaRef.current.currentTime\n\n      liveLatency = toFixedNumber(clamp(liveLatency, 0, seekRange.end), 4)\n\n      progress =\n        1 -\n        (seekRange.end - mediaRef.current.currentTime) /\n          (seekRange.end - seekRange.start)\n\n      progress = toFixedNumber(clamp(progress, 0, 1), 4)\n    } else {\n      currentTime = clamp(\n        mediaRef.current.currentTime,\n        0,\n        store.getState().duration\n      )\n      progress = toFixedNumber(currentTime / store.getState().duration, 4)\n    }\n\n    store.setState({\n      currentTime,\n      isLive: isLive,\n      liveLatency,\n      progress,\n      ...(isLive && {\n        duration: player.seekRange().end - player.seekRange().start,\n      }),\n    })\n  }\n\n  const onDurationChange = React.useCallback(() => {\n    if (!mediaRef.current || !player) return\n\n    const seekRange = player.seekRange()\n    const playerDuration = player.isLive()\n      ? seekRange.end - seekRange.start\n      : mediaRef.current.duration\n\n    if (playerDuration && Number.isFinite(playerDuration)) {\n      store.setState({ duration: playerDuration })\n    }\n  }, [store, mediaRef, player])\n\n  const onBuffer = React.useCallback(() => {\n    if (!player) return\n\n    const bufferedInfo = player.getBufferedInfo()\n\n    if (player.isBuffering()) {\n      return\n    }\n\n    store.setState({ buffered: bufferedInfo.total })\n  }, [store, player])\n\n  useInterval(onTimeUpdate, updateDuration)\n\n  React.useEffect(() => {\n    if (!mediaRef.current || !player) return noop\n\n    const media = mediaRef.current\n\n    if (canPlay) {\n      onTimeUpdate()\n      onDurationChange()\n      onBuffer()\n    }\n\n    on(media, [\"durationchange\", \"loading\"], onDurationChange)\n    on(media, \"progress\", onBuffer)\n    on(player, [\"trackschanged\", \"loading\"], onBuffer)\n\n    return () => {\n      off(media, [\"durationchange\", \"loading\"], onDurationChange)\n      off(media, \"progress\", onBuffer)\n      off(player, [\"trackschanged\", \"loading\"], onBuffer)\n    }\n  }, [mediaRef, player, canPlay])\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-timeline.ts"
    }
  ],
  "type": "registry:hook"
}