{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-player",
  "dependencies": [
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/utils.json",
    "https://limeplay.winoffrg.dev/r/media-provider.json",
    "https://limeplay.winoffrg.dev/r/player-hooks.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-player.ts",
      "content": "import type shaka from \"shaka-player\"\nimport type { StateCreator } from \"zustand\"\n\nimport React from \"react\"\n\nimport { noop, off, on } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport type MediaStatus =\n  | \"buffering\"\n  | \"canplay\"\n  | \"canplaythrough\"\n  | \"ended\"\n  | \"error\"\n  | \"init\"\n  | \"loading\"\n  | \"paused\"\n  | \"playing\"\n  | \"stopped\"\n\nexport const MediaReadyState = {\n  HAVE_CURRENT_DATA: 2,\n  HAVE_ENOUGH_DATA: 4,\n  HAVE_FUTURE_DATA: 3,\n  HAVE_METADATA: 1,\n  HAVE_NOTHING: 0,\n} as const\n\nexport type MediaReadyState =\n  (typeof MediaReadyState)[keyof typeof MediaReadyState]\n\nexport interface PlayerStore {\n  canPlay: boolean\n  canPlayThrough: boolean\n  debug: boolean\n  ended: boolean\n  error: MediaError | null\n  forceIdle: boolean\n  idle: boolean\n  loop: boolean\n  mediaRef: React.RefObject<HTMLMediaElement | null>\n  networkState: number\n  // Media State Store\n  paused: boolean\n  player: null | shaka.Player\n  playerContainerRef: HTMLDivElement | null\n  readyState: MediaReadyState\n  setDebug: (value: boolean) => void\n  setForceIdle: (value: boolean) => void\n  setIdle: (idle: boolean) => void\n  setMediaRef: (mediaRef: React.RefObject<HTMLMediaElement>) => void\n  setPlayer: (player: null | shaka.Player) => void\n  setPlayerContainerRef: (instance: HTMLDivElement | null) => void\n  status: MediaStatus\n}\n\nexport const createPlayerStore: StateCreator<\n  PlayerStore,\n  [],\n  [],\n  PlayerStore\n> = (set) => ({\n  canPlay: false,\n  canPlayThrough: false,\n  debug: false,\n  ended: false,\n  error: null,\n  forceIdle: false,\n  idle: false,\n  loop: false,\n  mediaRef: React.createRef<HTMLMediaElement>(),\n  networkState: 0,\n  paused: false,\n  player: null,\n  playerContainerRef: null,\n  readyState: MediaReadyState.HAVE_NOTHING,\n  setDebug: (value) => set({ debug: value }),\n  setForceIdle: (value) => set({ forceIdle: value }),\n  setIdle: (idle: boolean) => set({ idle }),\n  setMediaRef: (mediaRef: React.RefObject<HTMLMediaElement>) =>\n    set({ mediaRef }),\n  setPlayer: (player: null | shaka.Player) => set({ player }),\n  setPlayerContainerRef: (instance) => set({ playerContainerRef: instance }),\n  status: \"init\",\n})\n\nexport function usePlayer() {\n  const store = useGetStore()\n\n  function play() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.play().catch((error: unknown) => {\n      console.error(\"Error playing media\", error)\n      store.setState({\n        idle: false,\n        status: \"error\",\n      })\n    })\n\n    store.setState({\n      idle: false,\n    })\n  }\n\n  function pause() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.pause()\n\n    store.setState({\n      idle: false,\n    })\n  }\n\n  function togglePaused() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    if (media.paused) {\n      play()\n    } else {\n      pause()\n    }\n  }\n\n  function setLoop(loop: boolean) {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.loop = loop\n\n    store.setState({\n      idle: false,\n    })\n  }\n\n  function toggleLoop() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    setLoop(!media.loop)\n  }\n\n  function restart() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.currentTime = 0\n    if (media.paused) {\n      play()\n    }\n\n    store.setState({\n      ended: false,\n      idle: false,\n    })\n  }\n\n  return {\n    pause,\n    play,\n    restart,\n    setLoop,\n    toggleLoop,\n    togglePaused,\n  }\n}\n\nexport function usePlayerStates() {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n  const player = useMediaStore((state) => state.player)\n\n  React.useEffect(() => {\n    if (!mediaRef.current) return noop\n\n    const media = mediaRef.current\n\n    const setInitialState = () => {\n      const isBuffering = player?.isBuffering()\n      const status: MediaStatus = isBuffering\n        ? \"buffering\"\n        : media.paused\n          ? \"paused\"\n          : \"playing\"\n\n      store.setState({\n        canPlay: media.readyState >= MediaReadyState.HAVE_FUTURE_DATA,\n        canPlayThrough: media.readyState >= MediaReadyState.HAVE_ENOUGH_DATA,\n        ended: media.ended,\n        error: media.error,\n        loop: media.loop,\n        networkState: media.networkState,\n        paused: media.paused,\n        readyState: media.readyState as MediaReadyState,\n        status,\n      })\n    }\n\n    // Playback event handlers\n    const pauseHandler = () => {\n      store.setState({\n        paused: true,\n        status: \"paused\",\n      })\n    }\n\n    const playHandler = () => {\n      store.setState({\n        paused: false,\n        status: \"playing\",\n      })\n    }\n\n    const playingHandler = () => {\n      store.setState({\n        paused: false,\n        status: \"playing\",\n      })\n    }\n\n    const endedHandler = () => {\n      // DEV: When looping, ended event should be ignored to prevent UI showing ended state\n      if (media.loop) {\n        return\n      }\n      store.setState({\n        ended: true,\n        status: \"ended\",\n      })\n    }\n\n    // Loading event handlers\n    const loadStartHandler = () => {\n      store.setState({\n        error: null,\n        status: \"loading\",\n      })\n    }\n\n    const loadedMetadataHandler = () => {\n      store.setState({\n        ended: false,\n        readyState: media.readyState as MediaReadyState,\n      })\n    }\n\n    const loadedDataHandler = () => {\n      store.setState({\n        canPlay: media.readyState >= MediaReadyState.HAVE_FUTURE_DATA,\n        ended: false,\n        readyState: media.readyState as MediaReadyState,\n      })\n    }\n\n    const canPlayHandler = () => {\n      store.setState({\n        canPlay: true,\n        readyState: media.readyState as MediaReadyState,\n        status: media.paused ? \"paused\" : \"playing\",\n      })\n    }\n\n    const canPlayThroughHandler = () => {\n      store.setState({\n        canPlay: true,\n        canPlayThrough: true,\n        readyState: media.readyState as MediaReadyState,\n        status: media.paused ? \"paused\" : \"playing\",\n      })\n    }\n\n    const readyStateChangeHandler = () => {\n      const readyState = media.readyState as MediaReadyState\n\n      store.setState({\n        canPlay: readyState >= MediaReadyState.HAVE_FUTURE_DATA,\n        canPlayThrough: readyState >= MediaReadyState.HAVE_ENOUGH_DATA,\n        readyState,\n      })\n    }\n\n    const waitingHandler = () => {\n      store.setState({ status: \"buffering\" })\n    }\n\n    const stalledHandler = () => {\n      store.setState({ status: \"buffering\" })\n    }\n\n    const errorHandler = () => {\n      store.setState({\n        error: media.error,\n        status: \"error\",\n      })\n    }\n\n    const loopChangeHandler = () => {\n      store.setState({\n        loop: media.loop,\n      })\n    }\n\n    on(media, \"loadstart\", loadStartHandler)\n    on(media, \"loadedmetadata\", loadedMetadataHandler)\n    on(media, \"loadeddata\", loadedDataHandler)\n    on(media, \"canplay\", canPlayHandler)\n    on(media, \"canplaythrough\", canPlayThroughHandler)\n    on(media, \"readystatechange\", readyStateChangeHandler)\n    on(media, \"play\", playHandler)\n    on(media, \"playing\", playingHandler)\n    on(media, \"pause\", pauseHandler)\n    on(media, \"ended\", endedHandler)\n    on(media, \"waiting\", waitingHandler)\n    on(media, \"stalled\", stalledHandler)\n    on(media, \"error\", errorHandler)\n    on(media, \"loopchange\", loopChangeHandler)\n\n    setInitialState()\n\n    return () => {\n      off(media, \"loadstart\", loadStartHandler)\n      off(media, \"loadedmetadata\", loadedMetadataHandler)\n      off(media, \"loadeddata\", loadedDataHandler)\n      off(media, \"canplay\", canPlayHandler)\n      off(media, \"canplaythrough\", canPlayThroughHandler)\n      off(media, \"readystatechange\", readyStateChangeHandler)\n      off(media, \"play\", playHandler)\n      off(media, \"playing\", playingHandler)\n      off(media, \"pause\", pauseHandler)\n      off(media, \"ended\", endedHandler)\n      off(media, \"waiting\", waitingHandler)\n      off(media, \"stalled\", stalledHandler)\n      off(media, \"error\", errorHandler)\n      off(media, \"loopchange\", loopChangeHandler)\n    }\n  }, [store, mediaRef, player])\n\n  React.useEffect(() => {\n    if (!player) return noop\n\n    const bufferingHandler = () => {\n      const isBuffering = player.isBuffering()\n\n      if (isBuffering) {\n        store.setState({ status: \"buffering\" })\n      } else {\n        const media = mediaRef.current\n        if (media) {\n          const status = media.paused ? \"paused\" : \"playing\"\n          store.setState({ status })\n        }\n      }\n    }\n\n    const loadingHandler = () => {\n      store.setState({ status: \"loading\" })\n    }\n\n    player.addEventListener(\"buffering\", bufferingHandler)\n    player.addEventListener(\"loading\", loadingHandler)\n\n    return () => {\n      player.removeEventListener(\"buffering\", bufferingHandler)\n      player.removeEventListener(\"loading\", loadingHandler)\n    }\n  }, [player, mediaRef, store])\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-player.ts"
    }
  ],
  "type": "registry:hook"
}