{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-player",
  "dependencies": [
    "shaka-player",
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/media-provider.json",
    "https://limeplay.winoffrg.dev/r/player-hooks.json",
    "https://limeplay.winoffrg.dev/r/use-playback.json",
    "https://limeplay.winoffrg.dev/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-player.ts",
      "content": "\"use client\"\n\nimport type shaka from \"shaka-player\"\nimport type { StateCreator } from \"zustand\"\n\nimport React, { useRef } from \"react\"\n\nimport { noop, off, on } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\ndeclare global {\n  interface HTMLMediaElement {\n    player: null | shaka.Player\n  }\n  interface Window {\n    shaka: {\n      Player: typeof shaka.Player\n    }\n  }\n}\n\n/**\n * Playback store state - unopinionated, uses generics\n */\nexport interface PlayerStore {\n  onBufferingChange?: (payload: { isBuffering: boolean }) => void\n  onError?: (payload: { error: Error }) => void\n  onPlayerReady?: (payload: { player: shaka.Player }) => void\n\n  player: null | shaka.Player\n  playerContainerRef: HTMLDivElement | null\n  preloadManagers: Map<string, shaka.media.PreloadManager>\n\n  setPlayer: (player: null | shaka.Player) => void\n  setPlayerContainerRef: (instance: HTMLDivElement | null) => void\n}\n\nexport const createPlayerStore: StateCreator<\n  PlayerStore,\n  [],\n  [],\n  PlayerStore\n> = (set) => ({\n  onBufferingChange: undefined,\n  onError: undefined,\n  onPlayerReady: undefined,\n\n  player: null,\n  playerContainerRef: null,\n  preloadManagers: new Map(),\n\n  setPlayer: (player: null | shaka.Player) => set({ player }),\n  setPlayerContainerRef: (instance) => set({ playerContainerRef: instance }),\n})\n\n/**\n * Options for usePlayer hook\n */\nexport interface UsePlayerOptions<TAsset> {\n  /**\n   * Error handler - required\n   */\n  onError: (error: Error, asset?: TAsset) => void\n  /**\n   * Load implementation - required, user controls player.load/configure\n   */\n  onLoad: (\n    asset: TAsset,\n    player: shaka.Player,\n    media: HTMLMediaElement,\n    preloadManager?: shaka.media.PreloadManager\n  ) => Promise<void>\n  /**\n   * Preload implementation - required if using preload\n   */\n  onPreload?: (\n    asset: TAsset,\n    player: shaka.Player\n  ) => Promise<null | shaka.media.PreloadManager>\n}\n\nexport interface UsePlayerReturn<TAsset> {\n  cancelPreload: (assetId: string) => void\n  isPreloaded: (assetId: string) => boolean\n  load: (asset: TAsset) => Promise<boolean>\n  player: null | shaka.Player\n  preload: (asset: TAsset) => Promise<void>\n}\n\nexport function usePlayer<TAsset extends { id: string }>(\n  options?: UsePlayerOptions<TAsset>\n): UsePlayerReturn<TAsset> {\n  const store = useGetStore()\n\n  /**\n   * Load an asset\n   */\n  const load = React.useCallback(\n    async (asset: TAsset): Promise<boolean> => {\n      if (!options) return false\n\n      const currentPlayer = store.getState().player\n      const currentMedia = store.getState().mediaRef.current\n\n      if (!currentPlayer || !currentMedia) {\n        console.warn(\"[usePlayer] Player or media element not initialized\")\n        return false\n      }\n\n      try {\n        const preloadManagers = store.getState().preloadManagers\n        const preloadManager = preloadManagers.get(asset.id)\n\n        if (preloadManager) {\n          await options.onLoad(\n            asset,\n            currentPlayer,\n            currentMedia,\n            preloadManager\n          )\n          preloadManagers.delete(asset.id)\n          store.setState({ preloadManagers: new Map(preloadManagers) })\n        } else {\n          await options.onLoad(asset, currentPlayer, currentMedia)\n        }\n\n        return true\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error))\n        options.onError(err, asset)\n        return false\n      }\n    },\n    [store, options]\n  )\n\n  /**\n   * Preload an asset for faster playback later\n   */\n  const preload = React.useCallback(\n    async (asset: TAsset): Promise<void> => {\n      if (!options || !options.onPreload) return\n\n      const currentPlayer = store.getState().player\n      if (!currentPlayer) return\n\n      try {\n        const manager = await options.onPreload(asset, currentPlayer)\n        if (manager) {\n          const preloadManagers = store.getState().preloadManagers\n          preloadManagers.set(asset.id, manager)\n          store.setState({ preloadManagers: new Map(preloadManagers) })\n        }\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error))\n        options.onError(err, asset)\n        console.error(\"[usePlayer] Preload error:\", error)\n      }\n    },\n    [store, options]\n  )\n\n  /**\n   * Cancel a pending preload\n   */\n  const cancelPreload = React.useCallback(\n    (assetId: string): void => {\n      const preloadManagers = store.getState().preloadManagers\n      const manager = preloadManagers.get(assetId)\n      if (manager) {\n        manager.destroy()\n        preloadManagers.delete(assetId)\n        store.setState({ preloadManagers: new Map(preloadManagers) })\n      }\n    },\n    [store]\n  )\n\n  /**\n   * Check if an asset is preloaded\n   */\n  const isPreloaded = React.useCallback(\n    (assetId: string): boolean => {\n      return store.getState().preloadManagers.has(assetId)\n    },\n    [store]\n  )\n\n  const player = useMediaStore((s) => s.player)\n\n  return {\n    cancelPreload,\n    isPreloaded,\n    load,\n    player,\n    preload,\n  }\n}\nexport function usePlayerStates() {\n  const store = useGetStore()\n  const setPlayer = useMediaStore((state) => state.setPlayer)\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n  const debug = useMediaStore((state) => state.debug)\n  const player = useMediaStore((state) => state.player)\n\n  const playerInstance = useRef<null | shaka.Player>(null)\n\n  React.useLayoutEffect(() => {\n    const mediaElement = mediaRef.current\n\n    async function loadPlayer() {\n      const shakaLib = (\n        debug\n          ? await import(\"shaka-player/dist/shaka-player.compiled.debug\")\n          : await import(\"shaka-player\")\n      ).default\n\n      if (!mediaElement) {\n        return\n      }\n\n      const localPlayer = new shakaLib.Player() as shaka.Player\n      setPlayer(localPlayer)\n      playerInstance.current = localPlayer\n\n      try {\n        await localPlayer.attach(mediaElement)\n\n        mediaElement.player = playerInstance.current\n        window.shaka = shakaLib as unknown as Window[\"shaka\"]\n\n        store.getState().onPlayerReady?.({ player: localPlayer })\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error))\n        console.error(\n          \"[usePlayer] Failed to attach player to media element:\",\n          err\n        )\n\n        store.getState().onError?.({ error: err })\n      }\n    }\n\n    if (!playerInstance.current) {\n      void loadPlayer()\n    }\n\n    return () => {\n      if (playerInstance.current) {\n        playerInstance.current.destroy()\n        setPlayer(null)\n        playerInstance.current = null\n      }\n    }\n  }, [mediaRef, debug])\n\n  React.useEffect(() => {\n    if (!player) return noop\n\n    const setInitialState = () => {\n      if (player.isBuffering()) {\n        store.setState({ status: \"buffering\" })\n      }\n    }\n\n    const bufferingHandler = () => {\n      const isBuffering = player.isBuffering()\n\n      if (isBuffering) {\n        store.setState({ status: \"buffering\" })\n      } else {\n        const media = mediaRef.current\n        if (media) {\n          const status = media.paused ? \"paused\" : \"playing\"\n          store.setState({ status })\n        }\n      }\n\n      store.getState().onBufferingChange?.({ isBuffering })\n    }\n\n    const loadingHandler = () => {\n      store.setState({ status: \"loading\" })\n    }\n\n    on(player, \"buffering\", bufferingHandler)\n    on(player, \"loading\", loadingHandler)\n\n    setInitialState()\n\n    return () => {\n      off(player, \"buffering\", bufferingHandler)\n      off(player, \"loading\", loadingHandler)\n    }\n  }, [player, mediaRef, store])\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-player.ts"
    }
  ],
  "type": "registry:hook"
}