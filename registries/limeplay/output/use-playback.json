{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-playback",
  "dependencies": [
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/media-provider.json",
    "https://limeplay.winoffrg.dev/r/utils.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-playback.ts",
      "content": "import type { StateCreator } from \"zustand\"\n\nimport React from \"react\"\n\nimport { noop, off, on } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport type MediaStatus =\n  | \"buffering\"\n  | \"canplay\"\n  | \"canplaythrough\"\n  | \"ended\"\n  | \"error\"\n  | \"init\"\n  | \"loading\"\n  | \"paused\"\n  | \"playing\"\n  | \"stopped\"\n\nexport const MediaReadyState = {\n  HAVE_CURRENT_DATA: 2,\n  HAVE_ENOUGH_DATA: 4,\n  HAVE_FUTURE_DATA: 3,\n  HAVE_METADATA: 1,\n  HAVE_NOTHING: 0,\n} as const\n\nexport type MediaReadyState =\n  (typeof MediaReadyState)[keyof typeof MediaReadyState]\n\nexport interface PlaybackStore {\n  canPlay: boolean\n  canPlayThrough: boolean\n  debug: boolean\n  ended: boolean\n  error: MediaError | null\n  forceIdle: boolean\n  idle: boolean\n  loop: boolean\n  mediaRef: React.RefObject<HTMLMediaElement | null>\n  networkState: number\n  // Event callbacks\n  onBuffering?: (payload: { isBuffering: boolean }) => void\n  onEnded?: () => void\n  onPause?: () => void\n\n  onPlay?: () => void\n  onStatusChange?: (payload: {\n    prevStatus: MediaStatus\n    status: MediaStatus\n  }) => void\n  paused: boolean\n  readyState: MediaReadyState\n  setDebug: (value: boolean) => void\n\n  setForceIdle: (value: boolean) => void\n  setIdle: (idle: boolean) => void\n  setMediaRef: (mediaRef: React.RefObject<HTMLMediaElement>) => void\n  status: MediaStatus\n}\n\nexport const createPlaybackStore: StateCreator<\n  PlaybackStore,\n  [],\n  [],\n  PlaybackStore\n> = (set) => ({\n  canPlay: false,\n  canPlayThrough: false,\n  debug: false,\n  ended: false,\n  error: null,\n  forceIdle: false,\n  idle: false,\n  loop: false,\n  mediaRef: React.createRef<HTMLMediaElement>(),\n  networkState: 0,\n  onBuffering: undefined,\n  onEnded: undefined,\n  onPause: undefined,\n  onPlay: undefined,\n  onStatusChange: undefined,\n  paused: false,\n  readyState: MediaReadyState.HAVE_NOTHING,\n\n  setDebug: (value) => set({ debug: value }),\n  setForceIdle: (value) => set({ forceIdle: value }),\n  setIdle: (idle: boolean) => set({ idle }),\n  setMediaRef: (mediaRef: React.RefObject<HTMLMediaElement>) =>\n    set({ mediaRef }),\n  status: \"init\",\n})\n\nexport interface UsePlaybackReturn {\n  pause: () => void\n  play: () => void\n  restart: () => void\n  setLoop: (loop: boolean) => void\n  toggleLoop: () => void\n  togglePaused: () => void\n}\n\nexport function usePlayback(): UsePlaybackReturn {\n  const store = useGetStore()\n\n  function play() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.play().catch((error: unknown) => {\n      console.error(\"Error playing media\", error)\n      store.setState({\n        idle: false,\n        status: \"error\",\n      })\n    })\n\n    store.setState({\n      idle: false,\n    })\n  }\n\n  function pause() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.pause()\n\n    store.setState({\n      idle: false,\n    })\n  }\n\n  function togglePaused() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    if (media.paused) {\n      play()\n    } else {\n      pause()\n    }\n  }\n\n  function setLoop(loop: boolean) {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.loop = loop\n\n    store.setState({\n      idle: false,\n      loop,\n    })\n  }\n\n  function toggleLoop() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    setLoop(!media.loop)\n  }\n\n  function restart() {\n    const media = store.getState().mediaRef.current\n    if (!media) return\n\n    media.currentTime = 0\n    if (media.paused) {\n      play()\n    }\n\n    store.setState({\n      ended: false,\n      idle: false,\n    })\n  }\n\n  return {\n    pause,\n    play,\n    restart,\n    setLoop,\n    toggleLoop,\n    togglePaused,\n  }\n}\n\nexport function usePlaybackStates() {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n\n  React.useEffect(() => {\n    if (!mediaRef.current) return noop\n\n    const media = mediaRef.current\n\n    const setInitialState = () => {\n      const status: MediaStatus = media.paused ? \"paused\" : \"playing\"\n\n      store.setState({\n        canPlay: media.readyState >= MediaReadyState.HAVE_FUTURE_DATA,\n        canPlayThrough: media.readyState >= MediaReadyState.HAVE_ENOUGH_DATA,\n        ended: media.ended,\n        error: media.error,\n        loop: media.loop,\n        networkState: media.networkState,\n        paused: media.paused,\n        readyState: media.readyState as MediaReadyState,\n        status,\n      })\n    }\n\n    // Playback event handlers\n    const pauseHandler = () => {\n      const prevStatus = store.getState().status\n      store.setState({\n        paused: true,\n        status: \"paused\",\n      })\n\n      store.getState().onPause?.()\n      store.getState().onStatusChange?.({ prevStatus, status: \"paused\" })\n    }\n\n    const playHandler = () => {\n      const prevStatus = store.getState().status\n      store.setState({\n        paused: false,\n        status: \"playing\",\n      })\n\n      store.getState().onPlay?.()\n      store.getState().onStatusChange?.({ prevStatus, status: \"playing\" })\n    }\n\n    const playingHandler = () => {\n      const prevStatus = store.getState().status\n      store.setState({\n        paused: false,\n        status: \"playing\",\n      })\n\n      store.getState().onStatusChange?.({ prevStatus, status: \"playing\" })\n    }\n\n    const endedHandler = () => {\n      // DEV: When looping, ended event should be ignored to prevent UI showing ended state\n      if (media.loop) {\n        return\n      }\n      const prevStatus = store.getState().status\n      store.setState({\n        ended: true,\n        status: \"ended\",\n      })\n\n      store.getState().onEnded?.()\n      store.getState().onStatusChange?.({ prevStatus, status: \"ended\" })\n    }\n\n    // Loading event handlers\n    const loadStartHandler = () => {\n      store.setState({\n        error: null,\n        status: \"loading\",\n      })\n    }\n\n    const loadedMetadataHandler = () => {\n      store.setState({\n        ended: false,\n        readyState: media.readyState as MediaReadyState,\n      })\n    }\n\n    const loadedDataHandler = () => {\n      store.setState({\n        canPlay: media.readyState >= MediaReadyState.HAVE_FUTURE_DATA,\n        ended: false,\n        readyState: media.readyState as MediaReadyState,\n      })\n    }\n\n    const canPlayHandler = () => {\n      store.setState({\n        canPlay: true,\n        readyState: media.readyState as MediaReadyState,\n        status: media.paused ? \"paused\" : \"playing\",\n      })\n    }\n\n    const canPlayThroughHandler = () => {\n      store.setState({\n        canPlay: true,\n        canPlayThrough: true,\n        readyState: media.readyState as MediaReadyState,\n        status: media.paused ? \"paused\" : \"playing\",\n      })\n    }\n\n    const waitingHandler = () => {\n      const prevStatus = store.getState().status\n      store.setState({ status: \"buffering\" })\n\n      store.getState().onBuffering?.({ isBuffering: true })\n      store.getState().onStatusChange?.({ prevStatus, status: \"buffering\" })\n    }\n\n    const stalledHandler = () => {\n      const prevStatus = store.getState().status\n      store.setState({ status: \"buffering\" })\n\n      store.getState().onBuffering?.({ isBuffering: true })\n      store.getState().onStatusChange?.({ prevStatus, status: \"buffering\" })\n    }\n\n    const errorHandler = () => {\n      store.setState({\n        error: media.error,\n        status: \"error\",\n      })\n    }\n\n    on(media, \"loadstart\", loadStartHandler)\n    on(media, \"loadedmetadata\", loadedMetadataHandler)\n    on(media, \"loadeddata\", loadedDataHandler)\n    on(media, \"canplay\", canPlayHandler)\n    on(media, \"canplaythrough\", canPlayThroughHandler)\n    on(media, \"play\", playHandler)\n    on(media, \"playing\", playingHandler)\n    on(media, \"pause\", pauseHandler)\n    on(media, \"ended\", endedHandler)\n    on(media, \"waiting\", waitingHandler)\n    on(media, \"stalled\", stalledHandler)\n    on(media, \"error\", errorHandler)\n\n    setInitialState()\n\n    return () => {\n      off(media, \"loadstart\", loadStartHandler)\n      off(media, \"loadedmetadata\", loadedMetadataHandler)\n      off(media, \"loadeddata\", loadedDataHandler)\n      off(media, \"canplay\", canPlayHandler)\n      off(media, \"canplaythrough\", canPlayThroughHandler)\n      off(media, \"play\", playHandler)\n      off(media, \"playing\", playingHandler)\n      off(media, \"pause\", pauseHandler)\n      off(media, \"ended\", endedHandler)\n      off(media, \"waiting\", waitingHandler)\n      off(media, \"stalled\", stalledHandler)\n      off(media, \"error\", errorHandler)\n    }\n  }, [store, mediaRef])\n}\n",
      "type": "registry:hook",
      "target": "hooks/limeplay/use-playback.ts"
    }
  ],
  "type": "registry:hook"
}