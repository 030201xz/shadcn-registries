{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "persona",
  "type": "registry:component",
  "title": "Persona",
  "description": "AI-powered persona component.",
  "files": [
    {
      "path": "registry/default/ai-elements/persona.tsx",
      "type": "registry:component",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport {\n  type RiveParameters,\n  useRive,\n  useStateMachineInput,\n  useViewModel,\n  useViewModelInstance,\n  useViewModelInstanceColor,\n} from \"@rive-app/react-webgl2\";\nimport type { FC, ReactNode } from \"react\";\nimport { memo, useEffect, useMemo, useRef, useState } from \"react\";\n\nexport type PersonaState =\n  | \"idle\"\n  | \"listening\"\n  | \"thinking\"\n  | \"speaking\"\n  | \"asleep\";\n\ntype PersonaProps = {\n  state: PersonaState;\n  onLoad?: RiveParameters[\"onLoad\"];\n  onLoadError?: RiveParameters[\"onLoadError\"];\n  onReady?: () => void;\n  onPause?: RiveParameters[\"onPause\"];\n  onPlay?: RiveParameters[\"onPlay\"];\n  onStop?: RiveParameters[\"onStop\"];\n  className?: string;\n  variant?: keyof typeof sources;\n};\n\n// The state machine name is always 'default' for Elements AI visuals\nconst stateMachine = \"default\";\n\nconst sources = {\n  obsidian: {\n    source:\n      \"https://ejiidnob33g9ap1r.public.blob.vercel-storage.com/obsidian-2.0.riv\",\n    dynamicColor: true,\n    hasModel: true,\n  },\n  mana: {\n    source:\n      \"https://ejiidnob33g9ap1r.public.blob.vercel-storage.com/mana-2.0.riv\",\n    dynamicColor: false,\n    hasModel: true,\n  },\n  opal: {\n    source:\n      \"https://ejiidnob33g9ap1r.public.blob.vercel-storage.com/orb-1.2.riv\",\n    dynamicColor: false,\n    hasModel: false,\n  },\n  halo: {\n    source:\n      \"https://ejiidnob33g9ap1r.public.blob.vercel-storage.com/halo-2.0.riv\",\n    dynamicColor: true,\n    hasModel: true,\n  },\n  glint: {\n    source:\n      \"https://ejiidnob33g9ap1r.public.blob.vercel-storage.com/glint-2.0.riv\",\n    dynamicColor: true,\n    hasModel: true,\n  },\n  command: {\n    source:\n      \"https://ejiidnob33g9ap1r.public.blob.vercel-storage.com/command-2.0.riv\",\n    dynamicColor: true,\n    hasModel: true,\n  },\n};\n\nconst getCurrentTheme = (): \"light\" | \"dark\" => {\n  if (typeof window !== \"undefined\") {\n    if (document.documentElement.classList.contains(\"dark\")) {\n      return \"dark\";\n    }\n    if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n      return \"dark\";\n    }\n  }\n  return \"light\";\n};\n\nconst useTheme = (enabled: boolean) => {\n  const [theme, setTheme] = useState<\"light\" | \"dark\">(getCurrentTheme);\n\n  useEffect(() => {\n    // Skip if not enabled (avoids unnecessary observers for non-dynamic-color variants)\n    if (!enabled) {\n      return;\n    }\n\n    // Watch for classList changes\n    const observer = new MutationObserver(() => {\n      setTheme(getCurrentTheme());\n    });\n\n    observer.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: [\"class\"],\n    });\n\n    // Watch for OS-level theme changes\n    let mql: MediaQueryList | null = null;\n    const handleMediaChange = () => {\n      setTheme(getCurrentTheme());\n    };\n\n    if (window.matchMedia) {\n      mql = window.matchMedia(\"(prefers-color-scheme: dark)\");\n      mql.addEventListener(\"change\", handleMediaChange);\n    }\n\n    return () => {\n      observer.disconnect();\n      if (mql) {\n        mql.removeEventListener(\"change\", handleMediaChange);\n      }\n    };\n  }, [enabled]);\n\n  return theme;\n};\n\ntype PersonaWithModelProps = {\n  rive: ReturnType<typeof useRive>[\"rive\"];\n  source: (typeof sources)[keyof typeof sources];\n  children: React.ReactNode;\n};\n\nconst PersonaWithModel = memo(\n  ({ rive, source, children }: PersonaWithModelProps) => {\n    const theme = useTheme(source.dynamicColor);\n    const viewModel = useViewModel(rive, { useDefault: true });\n    const viewModelInstance = useViewModelInstance(viewModel, {\n      rive,\n      useDefault: true,\n    });\n    const viewModelInstanceColor = useViewModelInstanceColor(\n      \"color\",\n      viewModelInstance\n    );\n\n    useEffect(() => {\n      if (!(viewModelInstanceColor && source.dynamicColor)) {\n        return;\n      }\n\n      const [r, g, b] = theme === \"dark\" ? [255, 255, 255] : [0, 0, 0];\n      viewModelInstanceColor.setRgb(r, g, b);\n    }, [viewModelInstanceColor, theme, source.dynamicColor]);\n\n    return children;\n  }\n);\n\ntype PersonaWithoutModelProps = {\n  children: ReactNode;\n};\n\nconst PersonaWithoutModel = memo(\n  ({ children }: PersonaWithoutModelProps) => children\n);\n\nexport const Persona: FC<PersonaProps> = memo(\n  ({\n    variant = \"obsidian\",\n    state = \"idle\",\n    onLoad,\n    onLoadError,\n    onReady,\n    onPause,\n    onPlay,\n    onStop,\n    className,\n  }) => {\n    const source = sources[variant];\n\n    if (!source) {\n      throw new Error(`Invalid variant: ${variant}`);\n    }\n\n    // Stabilize callbacks to prevent useRive from reinitializing\n    const callbacksRef = useRef({\n      onLoad,\n      onLoadError,\n      onReady,\n      onPause,\n      onPlay,\n      onStop,\n    });\n    callbacksRef.current = {\n      onLoad,\n      onLoadError,\n      onReady,\n      onPause,\n      onPlay,\n      onStop,\n    };\n\n    const stableCallbacks = useMemo(\n      () => ({\n        onLoad: ((loadedRive) =>\n          callbacksRef.current.onLoad?.(\n            loadedRive\n          )) as RiveParameters[\"onLoad\"],\n        onLoadError: ((err) =>\n          callbacksRef.current.onLoadError?.(\n            err\n          )) as RiveParameters[\"onLoadError\"],\n        onReady: () => callbacksRef.current.onReady?.(),\n        onPause: ((event) =>\n          callbacksRef.current.onPause?.(event)) as RiveParameters[\"onPause\"],\n        onPlay: ((event) =>\n          callbacksRef.current.onPlay?.(event)) as RiveParameters[\"onPlay\"],\n        onStop: ((event) =>\n          callbacksRef.current.onStop?.(event)) as RiveParameters[\"onStop\"],\n      }),\n      []\n    );\n\n    const { rive, RiveComponent } = useRive({\n      src: source.source,\n      stateMachines: stateMachine,\n      autoplay: true,\n      onLoad: stableCallbacks.onLoad,\n      onLoadError: stableCallbacks.onLoadError,\n      onRiveReady: stableCallbacks.onReady,\n      onPause: stableCallbacks.onPause,\n      onPlay: stableCallbacks.onPlay,\n      onStop: stableCallbacks.onStop,\n    });\n\n    const listeningInput = useStateMachineInput(\n      rive,\n      stateMachine,\n      \"listening\"\n    );\n    const thinkingInput = useStateMachineInput(rive, stateMachine, \"thinking\");\n    const speakingInput = useStateMachineInput(rive, stateMachine, \"speaking\");\n    const asleepInput = useStateMachineInput(rive, stateMachine, \"asleep\");\n\n    useEffect(() => {\n      if (listeningInput) {\n        listeningInput.value = state === \"listening\";\n      }\n      if (thinkingInput) {\n        thinkingInput.value = state === \"thinking\";\n      }\n      if (speakingInput) {\n        speakingInput.value = state === \"speaking\";\n      }\n      if (asleepInput) {\n        asleepInput.value = state === \"asleep\";\n      }\n    }, [state, listeningInput, thinkingInput, speakingInput, asleepInput]);\n\n    const Component = source.hasModel ? PersonaWithModel : PersonaWithoutModel;\n\n    return (\n      <Component rive={rive} source={source}>\n        <RiveComponent className={cn(\"size-16 shrink-0\", className)} />\n      </Component>\n    );\n  }\n);\n",
      "target": "components/ai-elements/persona.tsx"
    }
  ],
  "dependencies": [
    "@rive-app/react-webgl2"
  ],
  "devDependencies": [],
  "registryDependencies": []
}