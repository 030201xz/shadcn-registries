{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "mic-selector",
  "type": "registry:component",
  "title": "Mic Selector",
  "description": "AI-powered mic selector component.",
  "files": [
    {
      "path": "registry/default/ai-elements/mic-selector.tsx",
      "type": "registry:component",
      "content": "\"use client\";\n\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Command,\n  CommandEmpty,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { cn } from \"@/lib/utils\";\nimport { ChevronsUpDownIcon } from \"lucide-react\";\nimport {\n  type ComponentProps,\n  createContext,\n  type ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\n\nconst deviceIdRegex = /\\(([\\da-fA-F]{4}:[\\da-fA-F]{4})\\)$/;\n\ntype MicSelectorContextType = {\n  data: MediaDeviceInfo[];\n  value: string | undefined;\n  onValueChange?: (value: string) => void;\n  open: boolean;\n  onOpenChange?: (open: boolean) => void;\n  width: number;\n  setWidth?: (width: number) => void;\n};\n\nconst MicSelectorContext = createContext<MicSelectorContextType>({\n  data: [],\n  value: undefined,\n  onValueChange: undefined,\n  open: false,\n  onOpenChange: undefined,\n  width: 200,\n  setWidth: undefined,\n});\n\nexport type MicSelectorProps = ComponentProps<typeof Popover> & {\n  defaultValue?: string;\n  value?: string | undefined;\n  onValueChange?: (value: string | undefined) => void;\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nexport const MicSelector = ({\n  defaultValue,\n  value: controlledValue,\n  onValueChange: controlledOnValueChange,\n  defaultOpen = false,\n  open: controlledOpen,\n  onOpenChange: controlledOnOpenChange,\n  ...props\n}: MicSelectorProps) => {\n  const [value, onValueChange] = useControllableState<string | undefined>({\n    defaultProp: defaultValue,\n    prop: controlledValue,\n    onChange: controlledOnValueChange,\n  });\n  const [open, onOpenChange] = useControllableState({\n    defaultProp: defaultOpen,\n    prop: controlledOpen,\n    onChange: controlledOnOpenChange,\n  });\n  const [width, setWidth] = useState(200);\n  const { devices, loading, hasPermission, loadDevices } = useAudioDevices();\n\n  useEffect(() => {\n    if (open && !hasPermission && !loading) {\n      loadDevices();\n    }\n  }, [open, hasPermission, loading, loadDevices]);\n\n  return (\n    <MicSelectorContext.Provider\n      value={{\n        data: devices,\n        value,\n        onValueChange,\n        open,\n        onOpenChange,\n        width,\n        setWidth,\n      }}\n    >\n      <Popover {...props} onOpenChange={onOpenChange} open={open} />\n    </MicSelectorContext.Provider>\n  );\n};\n\nexport type MicSelectorTriggerProps = ComponentProps<typeof Button>;\n\nexport const MicSelectorTrigger = ({\n  children,\n  ...props\n}: MicSelectorTriggerProps) => {\n  const { setWidth } = useContext(MicSelectorContext);\n  const ref = useRef<HTMLButtonElement>(null);\n\n  useEffect(() => {\n    // Create a ResizeObserver to detect width changes\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const newWidth = (entry.target as HTMLElement).offsetWidth;\n        if (newWidth) {\n          setWidth?.(newWidth);\n        }\n      }\n    });\n\n    if (ref.current) {\n      resizeObserver.observe(ref.current);\n    }\n\n    // Clean up the observer when component unmounts\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [setWidth]);\n\n  return (\n    <PopoverTrigger asChild>\n      <Button variant=\"outline\" {...props} ref={ref}>\n        {children}\n        <ChevronsUpDownIcon\n          className=\"shrink-0 text-muted-foreground\"\n          size={16}\n        />\n      </Button>\n    </PopoverTrigger>\n  );\n};\n\nexport type MicSelectorContentProps = ComponentProps<typeof Command> & {\n  popoverOptions?: ComponentProps<typeof PopoverContent>;\n};\n\nexport const MicSelectorContent = ({\n  className,\n  popoverOptions,\n  ...props\n}: MicSelectorContentProps) => {\n  const { width, onValueChange, value } = useContext(MicSelectorContext);\n\n  return (\n    <PopoverContent\n      className={cn(\"p-0\", className)}\n      style={{ width }}\n      {...popoverOptions}\n    >\n      <Command onValueChange={onValueChange} value={value} {...props} />\n    </PopoverContent>\n  );\n};\n\nexport type MicSelectorInputProps = ComponentProps<typeof CommandInput> & {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n};\n\nexport const MicSelectorInput = ({ ...props }: MicSelectorInputProps) => (\n  <CommandInput placeholder=\"Search microphones...\" {...props} />\n);\n\nexport type MicSelectorListProps = Omit<\n  ComponentProps<typeof CommandList>,\n  \"children\"\n> & {\n  children: (devices: MediaDeviceInfo[]) => ReactNode;\n};\n\nexport const MicSelectorList = ({\n  children,\n  ...props\n}: MicSelectorListProps) => {\n  const { data } = useContext(MicSelectorContext);\n\n  return <CommandList {...props}>{children(data)}</CommandList>;\n};\n\nexport type MicSelectorEmptyProps = ComponentProps<typeof CommandEmpty>;\n\nexport const MicSelectorEmpty = ({\n  children = \"No microphone found.\",\n  ...props\n}: MicSelectorEmptyProps) => <CommandEmpty {...props}>{children}</CommandEmpty>;\n\nexport type MicSelectorItemProps = ComponentProps<typeof CommandItem>;\n\nexport const MicSelectorItem = (props: MicSelectorItemProps) => {\n  const { onValueChange, onOpenChange } = useContext(MicSelectorContext);\n\n  return (\n    <CommandItem\n      onSelect={(currentValue) => {\n        onValueChange?.(currentValue);\n        onOpenChange?.(false);\n      }}\n      {...props}\n    />\n  );\n};\n\nexport type MicSelectorLabelProps = ComponentProps<\"span\"> & {\n  device: MediaDeviceInfo;\n};\n\nexport const MicSelectorLabel = ({\n  device,\n  className,\n  ...props\n}: MicSelectorLabelProps) => {\n  const matches = device.label.match(deviceIdRegex);\n\n  console.log(matches, device.label);\n\n  if (!matches) {\n    return (\n      <span className={className} {...props}>\n        {device.label}\n      </span>\n    );\n  }\n\n  const [, deviceId] = matches;\n  const name = device.label.replace(deviceIdRegex, \"\");\n\n  return (\n    <span className={className} {...props}>\n      <span>{name}</span>\n      <span className=\"text-muted-foreground\"> ({deviceId})</span>\n    </span>\n  );\n};\n\nexport type MicSelectorValueProps = ComponentProps<\"span\">;\n\nexport const MicSelectorValue = ({\n  className,\n  ...props\n}: MicSelectorValueProps) => {\n  const { data, value } = useContext(MicSelectorContext);\n  const currentDevice = data.find((d) => d.deviceId === value);\n\n  if (!currentDevice) {\n    return (\n      <span className={cn(\"flex-1 text-left\", className)} {...props}>\n        Select microphone...\n      </span>\n    );\n  }\n\n  return (\n    <MicSelectorLabel\n      className={cn(\"flex-1 text-left\", className)}\n      device={currentDevice}\n      {...props}\n    />\n  );\n};\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<MediaDeviceInfo[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [hasPermission, setHasPermission] = useState(false);\n\n  const loadDevicesWithoutPermission = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const deviceList = await navigator.mediaDevices.enumerateDevices();\n      const audioInputs = deviceList.filter(\n        (device) => device.kind === \"audioinput\"\n      );\n\n      setDevices(audioInputs);\n    } catch (err) {\n      const message =\n        err instanceof Error ? err.message : \"Failed to get audio devices\";\n\n      setError(message);\n      console.error(\"Error getting audio devices:\", message);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const loadDevicesWithPermission = useCallback(async () => {\n    if (loading) {\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const tempStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      for (const track of tempStream.getTracks()) {\n        track.stop();\n      }\n\n      const deviceList = await navigator.mediaDevices.enumerateDevices();\n      const audioInputs = deviceList.filter(\n        (device) => device.kind === \"audioinput\"\n      );\n\n      setDevices(audioInputs);\n      setHasPermission(true);\n    } catch (err) {\n      const message =\n        err instanceof Error ? err.message : \"Failed to get audio devices\";\n\n      setError(message);\n      console.error(\"Error getting audio devices:\", message);\n    } finally {\n      setLoading(false);\n    }\n  }, [loading]);\n\n  useEffect(() => {\n    loadDevicesWithoutPermission();\n  }, [loadDevicesWithoutPermission]);\n\n  useEffect(() => {\n    const handleDeviceChange = () => {\n      if (hasPermission) {\n        loadDevicesWithPermission();\n      } else {\n        loadDevicesWithoutPermission();\n      }\n    };\n\n    navigator.mediaDevices.addEventListener(\"devicechange\", handleDeviceChange);\n\n    return () => {\n      navigator.mediaDevices.removeEventListener(\n        \"devicechange\",\n        handleDeviceChange\n      );\n    };\n  }, [hasPermission, loadDevicesWithPermission, loadDevicesWithoutPermission]);\n\n  return {\n    devices,\n    loading,\n    error,\n    hasPermission,\n    loadDevices: loadDevicesWithPermission,\n  };\n};\n",
      "target": "components/ai-elements/mic-selector.tsx"
    }
  ],
  "dependencies": [
    "@radix-ui/react-use-controllable-state",
    "lucide-react"
  ],
  "devDependencies": [],
  "registryDependencies": [
    "button",
    "command",
    "popover"
  ]
}